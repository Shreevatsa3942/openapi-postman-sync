/**
 * Value Sanitizer for Postman Collections
 * 
 * Post-processes collections generated by openapi-to-postmanv2 to replace
 * random/garbage values with realistic, schema-aware defaults.
 * 
 * Resolution priority:
 *   1. User-provided values (--values-map)
 *   2. OpenAPI example annotations (already handled by converter)
 *   3. Enum values (pick first)
 *   4. Format-aware defaults (uuid, email, date-time, etc.)
 *   5. Field-name heuristics (firstName → "John", age → 25)
 *   6. Constraint-aware type fallback (respects min/max/minLength/maxLength)
 */

const { log } = require('./utils');

// ─── Built-in default value maps ──────────────────────────────────────────────

const FORMAT_DEFAULTS = {
    'uuid': '550e8400-e29b-41d4-a716-446655440000',
    'email': 'user@example.com',
    'date-time': '2025-01-15T10:30:00.000Z',
    'date': '2025-01-15',
    'time': '10:30:00',
    'uri': 'https://example.com',
    'url': 'https://example.com',
    'hostname': 'api.example.com',
    'ipv4': '192.168.1.1',
    'ipv6': '2001:0db8:85a3:0000:0000:8a2e:0370:7334',
    'byte': 'U29tZSBiYXNlNjQgZW5jb2RlZCBkYXRh',
    'binary': '<binary data>',
    'password': 'P@ssw0rd123',
    'int32': 42,
    'int64': 100000,
    'float': 3.14,
    'double': 3.14159265,
    'phone': '+1-555-0100',
};

const FIELD_NAME_DEFAULTS = {
    // Identifiers (ID suffix matching: petId, userId, etc.)
    'id': '550e8400-e29b-41d4-a716-446655440000',

    // Names
    'name': 'John Doe',
    'firstname': 'John',
    'first_name': 'John',
    'lastname': 'Doe',
    'last_name': 'Doe',
    'fullname': 'John Doe',
    'full_name': 'John Doe',
    'displayname': 'johndoe',
    'display_name': 'johndoe',
    'username': 'johndoe',
    'user_name': 'johndoe',
    'nickname': 'johnny',

    // Contact
    'email': 'user@example.com',
    'phone': '+1-555-0100',
    'phonenumber': '+1-555-0100',
    'phone_number': '+1-555-0100',
    'mobile': '+1-555-0100',

    // Address
    'address': '123 Main St',
    'street': '123 Main St',
    'city': 'Springfield',
    'state': 'IL',
    'zip': '62701',
    'zipcode': '62701',
    'zip_code': '62701',
    'postalcode': '62701',
    'postal_code': '62701',
    'country': 'US',
    'countrycode': 'US',
    'country_code': 'US',

    // Common business fields
    'title': 'Sample Title',
    'description': 'A sample description',
    'summary': 'A brief summary',
    'content': 'Sample content text',
    'message': 'Hello, this is a sample message',
    'comment': 'This is a sample comment',
    'note': 'A sample note',
    'notes': 'Sample notes',
    'label': 'Sample Label',
    'tag': 'general',
    'category': 'general',
    'type': 'default',
    'status': 'active',
    'role': 'user',

    // Numeric fields
    'age': 25,
    'count': 10,
    'quantity': 1,
    'amount': 100.00,
    'price': 29.99,
    'total': 99.99,
    'rating': 4.5,
    'score': 85,
    'weight': 70.5,
    'height': 175,
    'size': 10,
    'limit': 10,
    'offset': 0,
    'page': 1,
    'pagesize': 20,
    'page_size': 20,
    'per_page': 20,
    'order': 1,
    'priority': 1,
    'level': 1,
    'version': '1.0.0',
    'duration': 3600,
    'timeout': 30000,
    'retry': 3,
    'max': 100,
    'min': 0,

    // URLs and identifiers
    'url': 'https://example.com',
    'website': 'https://example.com',
    'homepage': 'https://example.com',
    'avatar': 'https://example.com/avatar.png',
    'image': 'https://example.com/image.png',
    'imageurl': 'https://example.com/image.png',
    'image_url': 'https://example.com/image.png',
    'icon': 'https://example.com/icon.png',
    'logo': 'https://example.com/logo.png',
    'link': 'https://example.com',
    'callback': 'https://example.com/callback',
    'redirect': 'https://example.com/redirect',
    'redirecturl': 'https://example.com/redirect',
    'redirect_url': 'https://example.com/redirect',
    'redirecturi': 'https://example.com/redirect',
    'redirect_uri': 'https://example.com/redirect',

    // Auth
    'password': 'P@ssw0rd123',
    'token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.sample',
    'accesstoken': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.sample',
    'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.sample',
    'refreshtoken': 'rt_sample_refresh_token_value',
    'refresh_token': 'rt_sample_refresh_token_value',
    'apikey': 'ak_sample_api_key_12345',
    'api_key': 'ak_sample_api_key_12345',
    'secret': 'sk_sample_secret_key_12345',

    // Boolean fields
    'active': true,
    'enabled': true,
    'verified': true,
    'published': true,
    'visible': true,
    'deleted': false,
    'archived': false,
    'locked': false,

    // Date/Time
    'date': '2025-01-15',
    'createdat': '2025-01-15T10:30:00.000Z',
    'created_at': '2025-01-15T10:30:00.000Z',
    'updatedat': '2025-01-16T14:00:00.000Z',
    'updated_at': '2025-01-16T14:00:00.000Z',
    'deletedat': '2025-01-17T09:00:00.000Z',
    'deleted_at': '2025-01-17T09:00:00.000Z',
    'startdate': '2025-01-15',
    'start_date': '2025-01-15',
    'enddate': '2025-02-15',
    'end_date': '2025-02-15',
    'expiresat': '2025-12-31T23:59:59.000Z',
    'expires_at': '2025-12-31T23:59:59.000Z',
    'birthday': '1990-05-20',
    'dob': '1990-05-20',
    'date_of_birth': '1990-05-20',
    'timestamp': '2025-01-15T10:30:00.000Z',

    // Locale
    'language': 'en',
    'locale': 'en-US',
    'timezone': 'America/New_York',
    'currency': 'USD',
    'currencycode': 'USD',
    'currency_code': 'USD',

    // Misc
    'color': '#3498db',
    'colour': '#3498db',
    'code': 'SAMPLE001',
    'sku': 'SKU-001',
    'barcode': '1234567890123',
    'serial': 'SN-001',
    'reference': 'REF-001',
    'key': 'sample-key',
    'value': 'sample-value',
};

// Type-based fallbacks when no format or field name match is found
const TYPE_DEFAULTS = {
    'string': 'sample-string',
    'integer': 1,
    'number': 1.0,
    'boolean': true,
};

// Patterns to detect randomly generated values from openapi-to-postmanv2
const RANDOM_VALUE_PATTERNS = {
    // Lorem-ipsum-style text (latin words typical of the library's random generator)
    // The \w* at the end allows matching truncated text (e.g. "exercitation est Lorem ir")
    loremIpsum: /^(lorem|ipsum|dolor|sit|amet|consectetur|adipiscing|elit|sed|do|eiusmod|tempor|incididunt|ut|labore|et|dolore|magna|aliqua|enim|ad|minim|veniam|quis|nostrud|exercitation|ullamco|laboris|nisi|aliquip|ex|ea|commodo|consequat|duis|aute|irure|in|reprehenderit|voluptate|velit|esse|cillum|fugiat|nulla|pariatur|excepteur|sint|occaecat|cupidatat|non|proident|sunt|culpa|qui|officia|deserunt|mollit|anim|id|est|laborum)(\s+(lorem|ipsum|dolor|sit|amet|consectetur|adipiscing|elit|sed|do|eiusmod|tempor|incididunt|ut|labore|et|dolore|magna|aliqua|enim|ad|minim|veniam|quis|nostrud|exercitation|ullamco|laboris|nisi|aliquip|ex|ea|commodo|consequat|duis|aute|irure|in|reprehenderit|voluptate|velit|esse|cillum|fugiat|nulla|pariatur|excepteur|sint|occaecat|cupidatat|non|proident|sunt|culpa|qui|officia|deserunt|mollit|anim|id|est|laborum))*(\s+\w*)?$/i,

    // Random email addresses (garbled local part or domain)
    // Catches patterns like: xhWusLJP6pS@xxx.jrxq, ILV@yjdcA.wx, h-c0mJT3sbFZvp0@qnK.kip
    randomEmail: (value) => {
        if (typeof value !== 'string') return false;
        // Must contain @ to be an email
        if (!value.includes('@')) return false;
        const [local, domain] = value.split('@');
        if (!local || !domain) return false;
        // Has unusual TLD (1-2 chars like .wx, or 5+ chars like .jrxq)
        const tldMatch = domain.match(/\.([a-z]+)$/i);
        if (tldMatch) {
            const tld = tldMatch[1];
            if (tld.length <= 2 || tld.length >= 5) return true;
        }
        // Has mostly random-looking characters (uppercase-lowercase mix with numbers in local)
        const hasRandomLocal = /^[a-zA-Z0-9\-_]{2,}$/.test(local) &&
            (/[A-Z]/.test(local) && /[a-z]/.test(local) && /[0-9]/.test(local));
        if (hasRandomLocal) return true;
        // Domain has no real TLD patterns, or has very short segments
        const domainParts = domain.split('.');
        if (domainParts.some(p => p.length <= 2 && p !== p.toLowerCase())) return true;
        // Domain name part (before TLD) has mixed case — real domains are lowercase
        if (domainParts.length >= 2 && /[A-Z]/.test(domainParts[0])) return true;
        // Very short domain part (1 char like 't' in 'ukZ@t.bebq')
        if (domainParts.some(p => p.length <= 1)) return true;
        return false;
    },

    // Dates far in the past (pre-2000) which are likely random
    oldDate: /^(19[0-8]\d|199[0-4])-\d{2}-\d{2}T/,

    // urn:uuid format (library-generated)
    urnUuid: /^urn:uuid:/,

    // Unreasonably large integers (likely random)
    largeInt: (value) => typeof value === 'number' && Number.isInteger(value) && Math.abs(value) > 1000000,
};

// ─── Schema extraction helpers ────────────────────────────────────────────────

/**
 * Build a lookup map from OpenAPI schemas for quick field info access.
 * Returns { schemaName: { fieldName: { type, format, enum, example, minimum, maximum, ... } } }
 */
function buildSchemaMap(openApiSpec) {
    const schemaMap = {};

    if (!openApiSpec || !openApiSpec.components || !openApiSpec.components.schemas) {
        return schemaMap;
    }

    for (const [schemaName, schema] of Object.entries(openApiSpec.components.schemas)) {
        if (schema.properties) {
            schemaMap[schemaName] = {};
            for (const [fieldName, fieldSchema] of Object.entries(schema.properties)) {
                schemaMap[schemaName][fieldName] = resolveSchemaRef(fieldSchema, openApiSpec);
            }
        }
    }

    return schemaMap;
}

/**
 * Resolve a $ref to the actual schema definition.
 */
function resolveSchemaRef(schema, openApiSpec) {
    if (!schema) return {};

    if (schema.$ref) {
        const refPath = schema.$ref.replace('#/', '').split('/');
        let resolved = openApiSpec;
        for (const part of refPath) {
            resolved = resolved?.[part];
        }
        return resolved || {};
    }

    return schema;
}

/**
 * Find the schema info for a field name across all known schemas.
 */
function findFieldSchema(fieldName, schemaMap) {
    for (const schema of Object.values(schemaMap)) {
        if (schema[fieldName]) {
            return schema[fieldName];
        }
    }
    return null;
}

// ─── Value resolution ─────────────────────────────────────────────────────────

/**
 * Check if a value appears to be randomly generated.
 */
function isRandomValue(value) {
    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (RANDOM_VALUE_PATTERNS.loremIpsum.test(trimmed)) return true;
        if (RANDOM_VALUE_PATTERNS.randomEmail(trimmed)) return true;
        if (RANDOM_VALUE_PATTERNS.oldDate.test(trimmed)) return true;
        if (RANDOM_VALUE_PATTERNS.urnUuid.test(trimmed)) return true;
    }
    if (RANDOM_VALUE_PATTERNS.largeInt(value)) return true;
    return false;
}

/**
 * Resolve the best value for a given field.
 * 
 * @param {string} fieldName - The field name (e.g. "email", "petId")
 * @param {object} fieldSchema - Schema info { type, format, enum, example, minimum, maximum, ... }
 * @param {object} userValuesMap - Optional user-provided value overrides
 * @param {string} endpointKey - Optional endpoint key (e.g. "POST:/pets") for endpoint-specific overrides
 * @returns {*} The resolved value, or null if no resolution found
 */
function resolveValue(fieldName, fieldSchema = {}, userValuesMap = null, endpointKey = null) {
    // 1. User-provided endpoint-specific override
    if (userValuesMap && endpointKey && userValuesMap.endpointOverrides) {
        const endpointOverrides = userValuesMap.endpointOverrides[endpointKey];
        if (endpointOverrides && endpointOverrides[fieldName] !== undefined) {
            return endpointOverrides[fieldName];
        }
    }

    // 2. User-provided field default
    if (userValuesMap && userValuesMap.fieldDefaults && userValuesMap.fieldDefaults[fieldName] !== undefined) {
        return userValuesMap.fieldDefaults[fieldName];
    }

    // 3. Schema example (already handled by converter, but as a fallback)
    if (fieldSchema.example !== undefined) {
        return fieldSchema.example;
    }

    // 4. Enum — pick first value
    if (fieldSchema.enum && fieldSchema.enum.length > 0) {
        return fieldSchema.enum[0];
    }

    // 5. Format-aware default
    if (fieldSchema.format && FORMAT_DEFAULTS[fieldSchema.format] !== undefined) {
        return FORMAT_DEFAULTS[fieldSchema.format];
    }

    // 6. Field-name heuristic
    const normalizedName = fieldName.toLowerCase().replace(/[-_]/g, '');
    // Try exact match first
    if (FIELD_NAME_DEFAULTS[fieldName] !== undefined) {
        return FIELD_NAME_DEFAULTS[fieldName];
    }
    // Try lowercase match
    if (FIELD_NAME_DEFAULTS[fieldName.toLowerCase()] !== undefined) {
        return FIELD_NAME_DEFAULTS[fieldName.toLowerCase()];
    }
    // Try normalized (no separators) match
    if (FIELD_NAME_DEFAULTS[normalizedName] !== undefined) {
        return FIELD_NAME_DEFAULTS[normalizedName];
    }
    // Try suffix matching (e.g. "petName" → match on "name")
    for (const [key, value] of Object.entries(FIELD_NAME_DEFAULTS)) {
        if (normalizedName.endsWith(key) && normalizedName !== key) {
            return value;
        }
    }

    // 7. Constraint-aware type fallback
    if (fieldSchema.type === 'integer' || fieldSchema.type === 'number') {
        return getConstrainedNumber(fieldSchema);
    }

    if (fieldSchema.type === 'string') {
        return getConstrainedString(fieldSchema);
    }

    // 8. Simple type fallback
    if (fieldSchema.type && TYPE_DEFAULTS[fieldSchema.type] !== undefined) {
        return TYPE_DEFAULTS[fieldSchema.type];
    }

    // 9. Infer format from the field name pattern (e.g. fields ending in Id are likely UUIDs)
    if (normalizedName.endsWith('id')) {
        return FORMAT_DEFAULTS['uuid'];
    }

    return null;
}

/**
 * Get a number value respecting min/max constraints.
 */
function getConstrainedNumber(schema) {
    const min = schema.minimum !== undefined ? schema.minimum : 0;
    const max = schema.maximum !== undefined ? schema.maximum : 100;
    // Pick a value that's 1/4 of the way from min to max (avoids boundary values)
    let value = min + Math.floor((max - min) / 4);
    if (value < min) value = min;
    if (value > max) value = max;
    if (schema.type === 'number') return parseFloat(value.toFixed(2));
    return value;
}

/**
 * Get a string value respecting minLength/maxLength constraints.
 */
function getConstrainedString(schema) {
    const base = 'sample-string';
    const minLen = schema.minLength || 0;
    const maxLen = schema.maxLength || 100;

    let result = base;
    // Pad if too short
    while (result.length < minLen) {
        result += '-text';
    }
    // Truncate if too long
    if (result.length > maxLen) {
        result = result.substring(0, maxLen);
    }
    return result;
}

// ─── Collection traversal and sanitization ────────────────────────────────────

/**
 * Sanitize an entire Postman collection, replacing random values with realistic ones.
 * 
 * @param {object} collection - The Postman collection object
 * @param {object} openApiSpec - The original OpenAPI specification
 * @param {object} userValuesMap - Optional user-provided value overrides
 * @returns {object} The sanitized collection
 */
function sanitizeCollection(collection, openApiSpec, userValuesMap = null) {
    if (!collection || !collection.item) {
        log.warn('No items found in collection to sanitize');
        return collection;
    }

    const schemaMap = buildSchemaMap(openApiSpec);
    let sanitizedCount = 0;

    const traverse = (items) => {
        for (const item of items) {
            if (item.item) {
                // Folder — recurse
                traverse(item.item);
            } else if (item.request) {
                // Request — sanitize
                const endpointKey = buildEndpointKey(item);
                sanitizedCount += sanitizeRequest(item.request, schemaMap, userValuesMap, endpointKey);

                // Sanitize response examples too
                if (item.response && Array.isArray(item.response)) {
                    for (const response of item.response) {
                        sanitizedCount += sanitizeResponseBody(response, schemaMap, userValuesMap, endpointKey);
                        // Also sanitize originalRequest inside response
                        if (response.originalRequest) {
                            sanitizedCount += sanitizeRequest(
                                response.originalRequest, schemaMap, userValuesMap, endpointKey
                            );
                        }
                    }
                }
            }
        }
    };

    traverse(collection.item);

    if (sanitizedCount > 0) {
        log.info(`Sanitized ${sanitizedCount} random values with realistic defaults`);
    } else {
        log.info('No random values detected — collection looks clean');
    }

    return collection;
}

/**
 * Build an endpoint key like "GET:/pets/{petId}" for matching user overrides.
 */
function buildEndpointKey(item) {
    if (!item.request) return '';
    const method = typeof item.request.method === 'string' ? item.request.method : 'GET';
    let urlPath = '';
    if (item.request.url) {
        if (typeof item.request.url === 'string') {
            urlPath = item.request.url;
        } else if (item.request.url.path) {
            const pathParts = Array.isArray(item.request.url.path)
                ? item.request.url.path
                : [item.request.url.path];
            urlPath = '/' + pathParts
                .filter(p => p !== '{{baseUrl}}' && p !== '')
                .map(p => p.startsWith(':') ? `{${p.slice(1)}}` : p)
                .join('/');
        }
    }
    return `${method}:${urlPath}`;
}

/**
 * Sanitize a request (body, query params, path variables).
 * Returns the number of values sanitized.
 */
function sanitizeRequest(request, schemaMap, userValuesMap, endpointKey) {
    let count = 0;

    // Sanitize request body (JSON)
    if (request.body && request.body.mode === 'raw' && request.body.raw) {
        try {
            const bodyObj = JSON.parse(request.body.raw);
            const { sanitized, changes } = sanitizeObject(bodyObj, schemaMap, userValuesMap, endpointKey);
            if (changes > 0) {
                request.body.raw = JSON.stringify(sanitized, null, 2);
                count += changes;
            }
        } catch (e) {
            // Not valid JSON, skip
        }
    }

    // Sanitize query parameters
    if (request.url && request.url.query) {
        for (const param of request.url.query) {
            if (param.value && isRandomValue(param.value)) {
                const schema = findFieldSchema(param.key, schemaMap) || {};
                const newValue = resolveValue(param.key, schema, userValuesMap, endpointKey);
                if (newValue !== null) {
                    param.value = String(newValue);
                    count++;
                }
            }
        }
    }

    // Sanitize path variables
    if (request.url && request.url.variable) {
        for (const variable of request.url.variable) {
            if (variable.value && isRandomValue(variable.value)) {
                const schema = findFieldSchema(variable.key, schemaMap) || {};
                const newValue = resolveValue(variable.key, schema, userValuesMap, endpointKey);
                if (newValue !== null) {
                    variable.value = String(newValue);
                    count++;
                }
            }
        }
    }

    return count;
}

/**
 * Sanitize a response body (JSON string).
 * Returns the number of values sanitized.
 */
function sanitizeResponseBody(response, schemaMap, userValuesMap, endpointKey) {
    if (!response.body || typeof response.body !== 'string') return 0;

    try {
        const bodyObj = JSON.parse(response.body);
        const { sanitized, changes } = sanitizeObject(bodyObj, schemaMap, userValuesMap, endpointKey);
        if (changes > 0) {
            response.body = JSON.stringify(sanitized, null, 2);
            return changes;
        }
    } catch (e) {
        // Not valid JSON, skip
    }
    return 0;
}

/**
 * Recursively sanitize an object or array, replacing random values.
 * Returns { sanitized, changes } where changes is the count of values replaced.
 */
function sanitizeObject(obj, schemaMap, userValuesMap, endpointKey) {
    let changes = 0;

    if (Array.isArray(obj)) {
        const sanitizedArr = obj.map(item => {
            if (typeof item === 'object' && item !== null) {
                const result = sanitizeObject(item, schemaMap, userValuesMap, endpointKey);
                changes += result.changes;
                return result.sanitized;
            }
            return item;
        });
        return { sanitized: sanitizedArr, changes };
    }

    if (typeof obj === 'object' && obj !== null) {
        const sanitized = {};
        for (const [key, value] of Object.entries(obj)) {
            if (typeof value === 'object' && value !== null) {
                const result = sanitizeObject(value, schemaMap, userValuesMap, endpointKey);
                sanitized[key] = result.sanitized;
                changes += result.changes;
            } else if (isRandomValue(value)) {
                const schema = findFieldSchema(key, schemaMap) || {};
                const newValue = resolveValue(key, schema, userValuesMap, endpointKey);
                if (newValue !== null) {
                    sanitized[key] = newValue;
                    changes++;
                } else {
                    sanitized[key] = value;
                }
            } else {
                sanitized[key] = value;
            }
        }
        return { sanitized, changes };
    }

    return { sanitized: obj, changes: 0 };
}

module.exports = {
    sanitizeCollection,
    resolveValue,
    isRandomValue,
    buildSchemaMap,
    findFieldSchema,
    buildEndpointKey,
    // Exported for testing
    FORMAT_DEFAULTS,
    FIELD_NAME_DEFAULTS,
    TYPE_DEFAULTS,
};
